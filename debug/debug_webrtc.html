<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebRTC Debug</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .container { max-width: 1200px; margin: 0 auto; }
        .section { margin: 20px 0; padding: 20px; border: 1px solid #ddd; border-radius: 8px; }
        .status { padding: 10px; margin: 10px 0; border-radius: 4px; }
        .success { background-color: #d4edda; color: #155724; border: 1px solid #c3e6cb; }
        .error { background-color: #f8d7da; color: #721c24; border: 1px solid #f5c6cb; }
        .info { background-color: #d1ecf1; color: #0c5460; border: 1px solid #bee5eb; }
        video { width: 100%; max-width: 400px; height: auto; background: black; }
        button { padding: 10px 20px; margin: 5px; cursor: pointer; }
        .logs { background: #f8f9fa; padding: 15px; max-height: 300px; overflow-y: auto; font-family: monospace; font-size: 12px; }
        .grid { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; }
    </style>
</head>
<body>
    <div class="container">
        <h1>WebRTC Debug Tool</h1>
        
        <div class="section">
            <h2>Service Status</h2>
            <div id="service-status"></div>
            <button onclick="checkServices()">Check Services</button>
        </div>

        <div class="grid">
            <div class="section">
                <h2>Host (Producer)</h2>
                <video id="localVideo" autoplay muted></video>
                <div>
                    <button onclick="startHost()">Start Host</button>
                    <button onclick="stopHost()">Stop Host</button>
                </div>
                <div id="host-status"></div>
                <div>Room ID: <span id="room-id">-</span></div>
            </div>

            <div class="section">
                <h2>Viewer (Consumer)</h2>
                <video id="remoteVideo" autoplay></video>
                <div>
                    <input type="text" id="viewer-room-id" placeholder="Enter Room ID" value="1b477fb0">
                    <button onclick="joinAsViewer()">Join as Viewer</button>
                    <button onclick="stopViewer()">Stop Viewer</button>
                </div>
                <div id="viewer-status"></div>
            </div>
        </div>

        <div class="section">
            <h2>Debug Logs</h2>
            <button onclick="clearLogs()">Clear Logs</button>
            <div id="logs" class="logs"></div>
        </div>
    </div>

    <script>
        // Global variables
        let localStream = null;
        let sfuSocket = null;
        let backendSocket = null;
        let currentRoomId = null;
        let device = null;
        let producerTransport = null;
        let consumerTransport = null;
        let videoProducer = null;
        let audioProducer = null;
        let videoConsumer = null;
        let audioConsumer = null;

        // Logging function
        function log(message, type = 'info') {
            const logs = document.getElementById('logs');
            const timestamp = new Date().toLocaleTimeString();
            const logEntry = document.createElement('div');
            logEntry.className = type;
            logEntry.innerHTML = `[${timestamp}] ${message}`;
            logs.appendChild(logEntry);
            logs.scrollTop = logs.scrollHeight;
            console.log(`[${type.toUpperCase()}] ${message}`);
        }

        function clearLogs() {
            document.getElementById('logs').innerHTML = '';
        }

        // Service status check
        async function checkServices() {
            const statusDiv = document.getElementById('service-status');
            statusDiv.innerHTML = 'Checking services...';

            const services = [
                { name: 'Backend', url: 'http://localhost:5000/health' },
                { name: 'Mediasoup', url: 'http://localhost:3001/health' },
                { name: 'Audio Redaction', url: 'http://localhost:5002/health' }
            ];

            let statusHtml = '';
            for (const service of services) {
                try {
                    const response = await fetch(service.url);
                    if (response.ok) {
                        statusHtml += `<div class="status success">✅ ${service.name}: Healthy</div>`;
                        log(`${service.name} service is healthy`);
                    } else {
                        statusHtml += `<div class="status error">❌ ${service.name}: Unhealthy (${response.status})</div>`;
                        log(`${service.name} service is unhealthy: ${response.status}`, 'error');
                    }
                } catch (error) {
                    statusHtml += `<div class="status error">❌ ${service.name}: Not reachable</div>`;
                    log(`${service.name} service is not reachable: ${error.message}`, 'error');
                }
            }
            statusDiv.innerHTML = statusHtml;
        }

        // Host functions
        async function startHost() {
            try {
                log('Starting host...');
                
                // Get user media
                localStream = await navigator.mediaDevices.getUserMedia({
                    video: true,
                    audio: true
                });
                document.getElementById('localVideo').srcObject = localStream;
                log('Got local media stream');

                // Connect to backend
                backendSocket = io('http://localhost:5000');
                await new Promise((resolve, reject) => {
                    backendSocket.on('connect', resolve);
                    backendSocket.on('connect_error', reject);
                    setTimeout(() => reject(new Error('Backend connection timeout')), 5000);
                });
                log('Connected to backend');

                // Create room
                await new Promise((resolve, reject) => {
                    backendSocket.emit('create_room');
                    backendSocket.on('room_created', (data) => {
                        currentRoomId = data.roomId;
                        document.getElementById('room-id').textContent = currentRoomId;
                        log(`Room created: ${currentRoomId}`);
                        resolve();
                    });
                    setTimeout(() => reject(new Error('Room creation timeout')), 5000);
                });

                // Connect to SFU
                sfuSocket = io('http://localhost:3001');
                await new Promise((resolve, reject) => {
                    sfuSocket.on('connect', resolve);
                    sfuSocket.on('connect_error', reject);
                    setTimeout(() => reject(new Error('SFU connection timeout')), 5000);
                });
                log('Connected to SFU');

                // Initialize mediasoup device
                const rtpCapabilities = await new Promise((resolve, reject) => {
                    sfuSocket.emit('get-router-rtp-capabilities', {}, (response) => {
                        if (response.success) {
                            resolve(response.rtpCapabilities);
                        } else {
                            reject(new Error(response.error));
                        }
                    });
                });

                device = new mediasoupClient.Device();
                await device.load({ routerRtpCapabilities: rtpCapabilities });
                log('Mediasoup device loaded');

                // Create producer transport
                const producerTransportInfo = await new Promise((resolve, reject) => {
                    sfuSocket.emit('create-producer-transport', { roomId: currentRoomId }, (response) => {
                        if (response.success) {
                            resolve(response.transportOptions);
                        } else {
                            reject(new Error(response.error));
                        }
                    });
                });

                producerTransport = device.createSendTransport(producerTransportInfo);
                
                producerTransport.on('connect', async ({ dtlsParameters }, callback, errback) => {
                    try {
                        sfuSocket.emit('connect-transport', {
                            transportId: producerTransport.id,
                            dtlsParameters
                        }, (response) => {
                            if (response.success) {
                                callback();
                            } else {
                                errback(new Error(response.error));
                            }
                        });
                    } catch (error) {
                        errback(error);
                    }
                });

                producerTransport.on('produce', async ({ kind, rtpParameters }, callback, errback) => {
                    try {
                        sfuSocket.emit('produce', {
                            roomId: currentRoomId,
                            transportId: producerTransport.id,
                            kind,
                            rtpParameters
                        }, (response) => {
                            if (response.success) {
                                callback({ id: response.producerId });
                                log(`Producer created: ${response.producerId} (${kind})`);
                            } else {
                                errback(new Error(response.error));
                            }
                        });
                    } catch (error) {
                        errback(error);
                    }
                });

                log('Producer transport created');

                // Create producers
                const videoTrack = localStream.getVideoTracks()[0];
                const audioTrack = localStream.getAudioTracks()[0];

                if (videoTrack) {
                    videoProducer = await producerTransport.produce({
                        track: videoTrack,
                        encodings: [
                            { maxBitrate: 100000 },
                            { maxBitrate: 300000 },
                            { maxBitrate: 900000 }
                        ],
                        codecOptions: {
                            videoGoogleStartBitrate: 1000
                        }
                    });
                    log('Video producer created');
                }

                if (audioTrack) {
                    audioProducer = await producerTransport.produce({
                        track: audioTrack
                    });
                    log('Audio producer created');
                }

                // Notify backend that streaming started
                backendSocket.emit('sfu_streaming_started', { roomId: currentRoomId });
                
                document.getElementById('host-status').innerHTML = '<div class="status success">✅ Broadcasting</div>';
                log('Host setup complete!');

            } catch (error) {
                log(`Host setup failed: ${error.message}`, 'error');
                document.getElementById('host-status').innerHTML = '<div class="status error">❌ Failed to start</div>';
            }
        }

        async function stopHost() {
            try {
                if (videoProducer) {
                    videoProducer.close();
                    videoProducer = null;
                }
                if (audioProducer) {
                    audioProducer.close();
                    audioProducer = null;
                }
                if (producerTransport) {
                    producerTransport.close();
                    producerTransport = null;
                }
                if (localStream) {
                    localStream.getTracks().forEach(track => track.stop());
                    localStream = null;
                }
                if (sfuSocket) {
                    sfuSocket.disconnect();
                    sfuSocket = null;
                }
                if (backendSocket) {
                    backendSocket.disconnect();
                    backendSocket = null;
                }

                document.getElementById('localVideo').srcObject = null;
                document.getElementById('host-status').innerHTML = '<div class="status info">ℹ️ Stopped</div>';
                document.getElementById('room-id').textContent = '-';
                currentRoomId = null;
                
                log('Host stopped');
            } catch (error) {
                log(`Error stopping host: ${error.message}`, 'error');
            }
        }

        // Viewer functions
        async function joinAsViewer() {
            try {
                const roomId = document.getElementById('viewer-room-id').value.trim();
                if (!roomId) {
                    throw new Error('Please enter a room ID');
                }

                log(`Joining room as viewer: ${roomId}`);

                // Connect to SFU
                if (!sfuSocket) {
                    sfuSocket = io('http://localhost:3001');
                    await new Promise((resolve, reject) => {
                        sfuSocket.on('connect', resolve);
                        sfuSocket.on('connect_error', reject);
                        setTimeout(() => reject(new Error('SFU connection timeout')), 5000);
                    });
                    log('Connected to SFU');
                }

                // Join room
                await new Promise((resolve, reject) => {
                    sfuSocket.emit('join-room', { roomId }, (response) => {
                        if (response.success) {
                            log(`Joined SFU room: ${roomId}`);
                            resolve();
                        } else {
                            reject(new Error(response.error));
                        }
                    });
                });

                // Initialize device if not already done
                if (!device) {
                    const rtpCapabilities = await new Promise((resolve, reject) => {
                        sfuSocket.emit('get-router-rtp-capabilities', {}, (response) => {
                            if (response.success) {
                                resolve(response.rtpCapabilities);
                            } else {
                                reject(new Error(response.error));
                            }
                        });
                    });

                    device = new mediasoupClient.Device();
                    await device.load({ routerRtpCapabilities: rtpCapabilities });
                    log('Mediasoup device loaded');
                }

                // Create consumer transport
                const consumerTransportInfo = await new Promise((resolve, reject) => {
                    sfuSocket.emit('create-consumer-transport', { roomId }, (response) => {
                        if (response.success) {
                            resolve(response.transportOptions);
                        } else {
                            reject(new Error(response.error));
                        }
                    });
                });

                consumerTransport = device.createRecvTransport(consumerTransportInfo);
                
                consumerTransport.on('connect', ({ dtlsParameters }, callback, errback) => {
                    sfuSocket.emit('connect-transport', {
                        transportId: consumerTransport.id,
                        dtlsParameters
                    }, (response) => {
                        if (response.success) {
                            callback();
                        } else {
                            errback(new Error(response.error));
                        }
                    });
                });

                log('Consumer transport created');

                // Listen for new producers
                sfuSocket.on('new-producer', async (data) => {
                    log(`New producer available: ${data.producerId} (${data.kind})`);
                    await consumeMedia(roomId, data.producerId, data.kind);
                });

                document.getElementById('viewer-status').innerHTML = '<div class="status success">✅ Viewing</div>';
                log('Viewer setup complete!');

            } catch (error) {
                log(`Viewer setup failed: ${error.message}`, 'error');
                document.getElementById('viewer-status').innerHTML = '<div class="status error">❌ Failed to join</div>';
            }
        }

        async function consumeMedia(roomId, producerId, kind) {
            try {
                log(`Consuming ${kind} from producer: ${producerId}`);

                const consumerInfo = await new Promise((resolve, reject) => {
                    sfuSocket.emit('consume', {
                        roomId,
                        transportId: consumerTransport.id,
                        producerId,
                        rtpCapabilities: device.rtpCapabilities
                    }, (response) => {
                        if (response.success) {
                            resolve(response.consumerOptions);
                        } else {
                            reject(new Error(response.error));
                        }
                    });
                });

                const consumer = await consumerTransport.consume(consumerInfo);
                
                // Resume consumer
                await new Promise((resolve, reject) => {
                    sfuSocket.emit('resume-consumer', {
                        consumerId: consumer.id
                    }, (response) => {
                        if (response.success) {
                            resolve();
                        } else {
                            reject(new Error(response.error));
                        }
                    });
                });

                const remoteVideo = document.getElementById('remoteVideo');
                
                if (kind === 'video') {
                    videoConsumer = consumer;
                    const stream = new MediaStream([consumer.track]);
                    if (!remoteVideo.srcObject) {
                        remoteVideo.srcObject = stream;
                    } else {
                        remoteVideo.srcObject.addTrack(consumer.track);
                    }
                    log('Video consumer ready');
                } else if (kind === 'audio') {
                    audioConsumer = consumer;
                    const stream = new MediaStream([consumer.track]);
                    if (!remoteVideo.srcObject) {
                        remoteVideo.srcObject = stream;
                    } else {
                        remoteVideo.srcObject.addTrack(consumer.track);
                    }
                    log('Audio consumer ready');
                }

                log(`${kind} consumption successful`);

            } catch (error) {
                log(`Failed to consume ${kind}: ${error.message}`, 'error');
            }
        }

        async function stopViewer() {
            try {
                if (videoConsumer) {
                    videoConsumer.close();
                    videoConsumer = null;
                }
                if (audioConsumer) {
                    audioConsumer.close();
                    audioConsumer = null;
                }
                if (consumerTransport) {
                    consumerTransport.close();
                    consumerTransport = null;
                }
                
                document.getElementById('remoteVideo').srcObject = null;
                document.getElementById('viewer-status').innerHTML = '<div class="status info">ℹ️ Stopped</div>';
                
                log('Viewer stopped');
            } catch (error) {
                log(`Error stopping viewer: ${error.message}`, 'error');
            }
        }

        // Initialize on page load
        window.onload = () => {
            checkServices();
        };
    </script>

    <!-- Load mediasoup-client from CDN -->
    <script src="https://unpkg.com/mediasoup-client@3.7.6/lib/mediasoup-client.js"></script>
    <!-- Load Socket.IO from CDN -->
    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
</body>
</html>